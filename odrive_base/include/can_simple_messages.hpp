
#pragma once

/**
 * @file can_simple_messages.hpp
 * @brief CAN message definitions for ODrive motor controller communication
 *
 * This file is autogenerated using generate_can_messages.py from the DBC definitions in can_dbc.py
 *
 * Each message struct provides:
 * - encode_buf(): Serializes message data into CAN payload buffer
 * - decode_buf(): Deserializes CAN payload buffer into message fields
 * - encode_msg()/decode_msg(): Wrapper functions for ODrive CAN interface (when ODRIVE_CAN_MSG_TYPE is defined)
 * - cmd_id: CAN message identifier for this message type
 * - msg_length: CAN payload size in bytes
 *
 * Messages are used to communicate motor commands (position, velocity, torque) and read
 * motor state (encoder estimates, currents, temperatures, errors).
 */

#include <stdint.h>

/**
 * @struct Heartbeat_msg_t
 * @brief Periodic status update from motor controller
 *
 * Command ID: 0x001
 * Payload: 8 bytes
 *
 * Contains axis state, error flags, and completion status. Typically sent on a timer
 * to provide continuous feedback about motor health and operation state.
 */
struct Heartbeat_msg_t final
{
    constexpr Heartbeat_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Heartbeat_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<uint32_t>(buf, Axis_Error, 0, 32, true);
        can_set_signal_raw<uint8_t>(buf, Axis_State, 32, 8, true);
        can_set_signal_raw<uint8_t>(buf, Motor_Error_Flag, 40, 1, true);
        can_set_signal_raw<uint8_t>(buf, Encoder_Error_Flag, 41, 1, true);
        can_set_signal_raw<uint8_t>(buf, Controller_Error_Flag, 42, 1, true);
        can_set_signal_raw<uint8_t>(buf, Trajectory_Done_Flag, 43, 1, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Axis_Error = can_get_signal_raw<uint32_t>(buf, 0, 32, true);
        Axis_State = can_get_signal_raw<uint8_t>(buf, 32, 8, true);
        Motor_Error_Flag = can_get_signal_raw<uint8_t>(buf, 40, 1, true);
        Encoder_Error_Flag = can_get_signal_raw<uint8_t>(buf, 41, 1, true);
        Controller_Error_Flag = can_get_signal_raw<uint8_t>(buf, 42, 1, true);
        Trajectory_Done_Flag = can_get_signal_raw<uint8_t>(buf, 48, 1, true);
    }

    static const uint8_t cmd_id = 0x001;
    static const uint8_t msg_length = 8;

    uint32_t Axis_Error = 0;
    uint8_t Axis_State = 0;
    uint8_t Motor_Error_Flag = 0;
    uint8_t Encoder_Error_Flag = 0;
    uint8_t Controller_Error_Flag = 0;
    uint8_t Trajectory_Done_Flag = 0;
};

/**
 * @struct Estop_msg_t
 * @brief Emergency stop command
 *
 * Command ID: 0x002
 * Payload: 0 bytes (command only, no parameters)
 *
 * Immediately disables motor output and sets error state. Used for safety-critical
 * situations requiring rapid motor shutdown.
 */
struct Estop_msg_t final
{
    constexpr Estop_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Estop_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
    }

    void decode_buf(const uint8_t *buf)
    {
    }

    static const uint8_t cmd_id = 0x002;
    static const uint8_t msg_length = 0;
};

/**
 * @struct Get_Motor_Error_msg_t
 * @brief Query Motor error information
 *
 * Command ID: 0x003
 * Payload: 8 bytes
 *
 * Returns motorerror codes 
 * debugging and error recovery.
 */
struct Get_Motor_Error_msg_t final
{
    constexpr Get_Motor_Error_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Get_Motor_Error_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<uint32_t>(buf, Motor_Error, 0, 64, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Motor_Error = can_get_signal_raw<uint32_t>(buf, 0, 64, true);
    }

    static const uint8_t cmd_id = 0x003;
    static const uint8_t msg_length = 8;

    uint64_t Motor_Error = 0;
};

/**
 * @struct Get_Encoder_Error_msg_t
 * @brief Query Encoder error information
 *
 * Command ID: 0x004
 * Payload: 8 bytes
 *
 * Returns encodererror code
 * debugging and error recovery.
 */
struct Get_Encoder_Error_msg_t final
{
    constexpr Get_Encoder_Error_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Get_Encoder_Error_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<uint32_t>(buf, Encoder_Error, 0, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Encoder_Error = can_get_signal_raw<uint32_t>(buf, 0, 32, true);
    }

    static const uint8_t cmd_id = 0x004;
    static const uint8_t msg_length = 8;

    uint32_t Encoder_Error = 0;
};

/**
 * @struct Get_Sensorless_Error_msg_t
 * @brief Query Sensorless error information
 *
 * Command ID: 0x005
 * Payload: 8 bytes
 *
 * Returns sensorlesserror code
 * debugging and error recovery.
 */
struct Get_Sensorless_Error_msg_t final
{
    constexpr Get_Sensorless_Error_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Get_Sensorless_Error_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<uint32_t>(buf, Sensorless_Error, 0, 64, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Sensorless_Error = can_get_signal_raw<uint32_t>(buf, 0, 64, true);
    }

    static const uint8_t cmd_id = 0x005;
    static const uint8_t msg_length = 8;

    uint32_t Sensorless_Error = 0;
};

/**
 * @struct Address_msg_t
 * @brief Motor controller identification
 *
 * Command ID: 0x006
 * Payload: 8 bytes
 *
 * Sets node ID for multi-motor CAN bus identification.
 */
struct Set_Node_ID_msg_t final
{
    constexpr Set_Node_ID_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Set_Node_ID_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<uint32_t>(buf, Node_ID, 0, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Node_ID = can_get_signal_raw<uint32_t>(buf, 0, 32, true);
    }

    static const uint8_t cmd_id = 0x006;
    static const uint8_t msg_length = 8;

    uint32_t Node_ID = 0;
};

/**
 * @struct Set_Axis_State_msg_t
 * @brief Set motor operational state
 *
 * Command ID: 0x007
 * Payload: 8 bytes
 *
 * Controls motor state transitions (idle, calibration, closed-loop, etc.).
 */
struct Set_Axis_State_msg_t final
{
    constexpr Set_Axis_State_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Set_Axis_State_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<uint32_t>(buf, Axis_Requested_State, 0, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Axis_Requested_State = can_get_signal_raw<uint32_t>(buf, 0, 32, true);
    }

    static const uint8_t cmd_id = 0x007;
    static const uint8_t msg_length = 8;

    uint32_t Axis_Requested_State = 0;
};

/**
 * @struct Get_Encoder_Estimates_msg_t
 * @brief Query motor position and velocity estimates
 *
 * Command ID: 0x009
 * Payload: 8 bytes
 *
 * Position in revolutions and velocity in revolutions per second from encoder feedback.
 * Used for motor state feedback and closed-loop control validation.
 */
struct Get_Encoder_Estimates_msg_t final
{
    constexpr Get_Encoder_Estimates_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Get_Encoder_Estimates_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, Pos_Estimate, 0, 32, true);
        can_set_signal_raw<float>(buf, Vel_Estimate, 32, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Pos_Estimate = can_get_signal_raw<float>(buf, 0, 32, true);
        Vel_Estimate = can_get_signal_raw<float>(buf, 32, 32, true);
    }

    static const uint8_t cmd_id = 0x009;
    static const uint8_t msg_length = 8;

    float Pos_Estimate = 0.0f; // [rev]
    float Vel_Estimate = 0.0f; // [rev/s]
};

/**
 * @struct Get_Encoder_Count_msg_t
 * @brief Get raw encoder counts
 *
 * Command ID: 0x00A
 * Payload: 8 bytes
 *
 */
struct Get_Encoder_Count_msg_t final
{
    constexpr Get_Encoder_Count_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Get_Encoder_Count_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<uint32_t>(buf, Shadow_count, 0, 32, true);
        can_set_signal_raw<uint32_t>(buf, CPR_count, 32, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Shadow_count = can_get_signal_raw<uint32_t>(buf, 0, 32, true);
        CPR_count = can_get_signal_raw<uint32_t>(buf, 32, 32, true);
    }

    static const uint8_t cmd_id = 0x00A;
    static const uint8_t msg_length = 8;

    int32_t Shadow_count = 0;
    int32_t CPR_count = 0;
};

/**
 * @struct Set_Controller_Mode_msg_t
 * @brief Configure motor control algorithm and input interpretation
 *
 * Command ID: 0x00B
 * Payload: 8 bytes
 *
 * Selects control mode (voltage, current, velocity, position) and input mode
 * (position/velocity setpoint source).
 */
struct Set_Controller_Mode_msg_t final
{
    constexpr Set_Controller_Mode_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Set_Controller_Mode_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<uint32_t>(buf, Control_Mode, 0, 32, true);
        can_set_signal_raw<uint32_t>(buf, Input_Mode, 32, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Control_Mode = can_get_signal_raw<uint32_t>(buf, 0, 32, true);
        Input_Mode = can_get_signal_raw<uint32_t>(buf, 32, 32, true);
    }

    static const uint8_t cmd_id = 0x00B;
    static const uint8_t msg_length = 8;

    uint32_t Control_Mode = 0;
    uint32_t Input_Mode = 0;
};

/**
 * @struct Set_Input_Pos_msg_t
 * @brief Command motor to move to target position
 *
 * Command ID: 0x00C
 * Payload: 8 bytes
 *
 * Position command with optional velocity and torque feedforward for smooth motion.
 * Position in revolutions, velocity in rev/s, torque in Newton-meters.
 */
struct Set_Input_Pos_msg_t final
{
    constexpr Set_Input_Pos_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Set_Input_Pos_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, Input_Pos, 0, 32, true);
        can_set_signal_raw<int16_t>(buf, Vel_FF, 32, 16, true, 0.001f, 0.0f);
        can_set_signal_raw<int16_t>(buf, Torque_FF, 48, 16, true, 0.001f, 0.0f);
    }

    void decode_buf(const uint8_t *buf)
    {
        Input_Pos = can_get_signal_raw<float>(buf, 0, 32, true);
        Vel_FF = can_get_signal_raw<int16_t>(buf, 32, 16, true, 0.001f, 0.0f);
        Torque_FF = can_get_signal_raw<int16_t>(buf, 48, 16, true, 0.001f, 0.0f);
    }

    static const uint8_t cmd_id = 0x00C;
    static const uint8_t msg_length = 8;

    float Input_Pos = 0.0f; // [rev]
    float Vel_FF = 0.0f;    // [rev/s]
    float Torque_FF = 0.0f; // [Nm]
};

/**
 * @struct Set_Input_Vel_msg_t
 * @brief Command motor to rotate at target velocity
 *
 * Command ID: 0x00D
 * Payload: 8 bytes
 *
 * Velocity setpoint with optional torque feedforward for smooth acceleration.
 * Velocity in rev/s, torque in Newton-meters.
 */
struct Set_Input_Vel_msg_t final
{
    constexpr Set_Input_Vel_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Set_Input_Vel_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, Input_Vel, 0, 32, true);
        can_set_signal_raw<float>(buf, Input_Torque_FF, 32, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Input_Vel = can_get_signal_raw<float>(buf, 0, 32, true);
        Input_Torque_FF = can_get_signal_raw<float>(buf, 32, 32, true);
    }

    static const uint8_t cmd_id = 0x00D;
    static const uint8_t msg_length = 8;

    float Input_Vel = 0.0f;       // [rev/s]
    float Input_Torque_FF = 0.0f; // [Nm]
};

/**
 * @struct Set_Input_Torque_msg_t
 * @brief Direct torque control command
 *
 * Command ID: 0x00E
 * Payload: 8 bytes
 *
 * Directly sets motor torque output in Newton-meters. Used for force-controlled
 * applications or torque feedforward in other control modes.
 */
struct Set_Input_Torque_msg_t final
{
    constexpr Set_Input_Torque_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Set_Input_Torque_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, Input_Torque, 0, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Input_Torque = can_get_signal_raw<float>(buf, 0, 32, true);
    }

    static const uint8_t cmd_id = 0x00E;
    static const uint8_t msg_length = 8;

    float Input_Torque = 0.0f; // [Nm]
};

/**
 * @struct Set_Limits_msg_t
 * @brief Configure motor safety limits
 *
 * Command ID: 0x00F
 * Payload: 8 bytes
 *
 * Sets maximum velocity (rev/s) and current (Amperes) to prevent motor damage
 * and ensure safe operation within physical constraints.
 */
struct Set_Limits_msg_t final
{
    constexpr Set_Limits_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Set_Limits_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, Velocity_Limit, 0, 32, true);
        can_set_signal_raw<float>(buf, Current_Limit, 32, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Velocity_Limit = can_get_signal_raw<float>(buf, 0, 32, true);
        Current_Limit = can_get_signal_raw<float>(buf, 32, 32, true);
    }

    static const uint8_t cmd_id = 0x00F;
    static const uint8_t msg_length = 8;

    float Velocity_Limit = 0.0f; // [rev/s]
    float Current_Limit = 0.0f;  // [A]
};

/**
 * @struct Start_Anticog_msg_t
 * @brief Start Anticogging command
 *
 * Command ID: 0x010
 * Payload: 0 bytes (command only, no parameters)
 *
 * Start Anticogging
 */
struct Start_Anticog_msg_t final
{
    constexpr Start_Anticog_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Start_Anticog_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
    }

    void decode_buf(const uint8_t *buf)
    {
    }

    static const uint8_t cmd_id = 0x010;
    static const uint8_t msg_length = 0;
};

/**
 * @struct Set_Traj_Vel_Limit_msg_t
 * @brief Configure trajectory maximum velocity
 *
 * Command ID: 0x011
 * Payload: 8 bytes
 *
 * Sets trajectory generator velocity constraint for smooth, bounded motion.
 * Velocity in rev/s.
 */
struct Set_Traj_Vel_Limit_msg_t final
{
    constexpr Set_Traj_Vel_Limit_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Set_Traj_Vel_Limit_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, Traj_Vel_Limit, 0, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Traj_Vel_Limit = can_get_signal_raw<float>(buf, 0, 32, true);
    }

    static const uint8_t cmd_id = 0x011;
    static const uint8_t msg_length = 8;

    float Traj_Vel_Limit = 0.0f; // [rev/s]
};

/**
 * @struct Set_Traj_Accel_Limits_msg_t
 * @brief Configure trajectory acceleration and deceleration limits
 *
 * Command ID: 0x012
 * Payload: 8 bytes
 *
 * Separate acceleration and deceleration ramps for trajectory planning.
 * Both in rev/s².
 */
struct Set_Traj_Accel_Limits_msg_t final
{
    constexpr Set_Traj_Accel_Limits_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Set_Traj_Accel_Limits_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, Traj_Accel_Limit, 0, 32, true);
        can_set_signal_raw<float>(buf, Traj_Decel_Limit, 32, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Traj_Accel_Limit = can_get_signal_raw<float>(buf, 0, 32, true);
        Traj_Decel_Limit = can_get_signal_raw<float>(buf, 32, 32, true);
    }

    static const uint8_t cmd_id = 0x012;
    static const uint8_t msg_length = 8;

    float Traj_Accel_Limit = 0.0f; // [rev/s^2]
    float Traj_Decel_Limit = 0.0f; // [rev/s^2]
};

/**
 * @struct Set_Traj_Inertia_msg_t
 * @brief Configure load inertia for trajectory planning
 *
 * Command ID: 0x013
 * Payload: 8 bytes
 *
 * Inertia value in Nm/(rev/s²) used for feedforward calculations in
 * trajectory-based motion control.
 */
struct Set_Traj_Inertia_msg_t final
{
    constexpr Set_Traj_Inertia_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Set_Traj_Inertia_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, Traj_Inertia, 0, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Traj_Inertia = can_get_signal_raw<float>(buf, 0, 32, true);
    }

    static const uint8_t cmd_id = 0x013;
    static const uint8_t msg_length = 8;

    float Traj_Inertia = 0.0f; // [Nm/(rev/s^2)]
};

/**
 * @struct Get_Iq_msg_t
 * @brief Query motor q-axis current (torque-producing)
 *
 * Command ID: 0x014
 * Payload: 8 bytes
 *
 * Returns both commanded and measured q-axis current in Amperes.
 * Used for current loop diagnostics and torque monitoring.
 */
struct Get_Iq_msg_t final
{
    constexpr Get_Iq_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Get_Iq_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, Iq_Setpoint, 0, 32, true);
        can_set_signal_raw<float>(buf, Iq_Measured, 32, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Iq_Setpoint = can_get_signal_raw<float>(buf, 0, 32, true);
        Iq_Measured = can_get_signal_raw<float>(buf, 32, 32, true);
    }

    static const uint8_t cmd_id = 0x014;
    static const uint8_t msg_length = 8;

    float Iq_Setpoint = 0.0f; // [A]
    float Iq_Measured = 0.0f; // [A]
};

/**
 * @struct Get_Sensorless_Estimates_msg_t
 * @brief Query Sensorless position and velocity estimates
 *
 * Command ID: 0x015
 * Payload: 8 bytes
 * 
 */
struct Get_Sensorless_Estimates_msg_t final
{
    constexpr Get_Sensorless_Estimates_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Get_Sensorless_Estimates_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, Sensorless_Pos_Estimate, 0, 32, true);
        can_set_signal_raw<float>(buf, Sensorless_Vel_Estimate, 32, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Sensorless_Pos_Estimate = can_get_signal_raw<float>(buf, 0, 32, true);
        Sensorless_Vel_Estimate = can_get_signal_raw<float>(buf, 32, 32, true);
    }

    static const uint8_t cmd_id = 0x015;
    static const uint8_t msg_length = 8;

    float Sensorless_Pos_Estimate = 0.0f;   // [deg C]
    float Sensorless_Vel_Estimate = 0.0f; // [deg C]
};

/**
 * @struct Reboot_msg_t
 * @brief Reboot motor controller
 *
 * Command ID: 0x016
 * Payload: 0 bytes
 *
 * Triggers controller restart. Used for recovery from fault states or
 * resetting configuration.
 */
struct Reboot_msg_t final
{
    constexpr Reboot_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Reboot_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
    }

    void decode_buf(const uint8_t *buf)
    {
    }

    static const uint8_t cmd_id = 0x016;
    static const uint8_t msg_length = 0;
};

/**
 * @struct Get_Bus_Voltage_Current_msg_t
 * @brief Query power supply bus voltage and current
 *
 * Command ID: 0x017
 * Payload: 8 bytes
 *
 * Returns DC bus voltage in Volts and current in Amperes.
 * Used for power monitoring and thermal load assessment.
 */
struct Get_Bus_Voltage_Current_msg_t final
{
    constexpr Get_Bus_Voltage_Current_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Get_Bus_Voltage_Current_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, Bus_Voltage, 0, 32, true);
        can_set_signal_raw<float>(buf, Bus_Current, 32, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Bus_Voltage = can_get_signal_raw<float>(buf, 0, 32, true);
        Bus_Current = can_get_signal_raw<float>(buf, 32, 32, true);
    }

    static const uint8_t cmd_id = 0x017;
    static const uint8_t msg_length = 8;

    float Bus_Voltage = 0.0f; // [V]
    float Bus_Current = 0.0f; // [A]
};

/**
 * @struct Clear_Errors_msg_t
 * @brief Clear error flags and optionally identify node
 *
 * Command ID: 0x018
 * Payload: 0 bytes
 *
 * Clears latched error conditions. 
 */
struct Clear_Errors_msg_t final
{
    constexpr Clear_Errors_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Clear_Errors_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
    }

    void decode_buf(const uint8_t *buf)
    {
    }

    static const uint8_t cmd_id = 0x018;
    static const uint8_t msg_length = 0;
};

/**
 * @struct Set_Linear_Count_msg_t
 * @brief Calibrate/set absolute encoder position
 *
 * Command ID: 0x019
 * Payload: 8 bytes
 *
 * Sets the motor's position estimate in revolutions. Used during homing
 * or position calibration procedures.
 */
struct Set_Linear_Count_msg_t final
{
    constexpr Set_Linear_Count_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Set_Linear_Count_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<int32_t>(buf, Position, 0, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Position = can_get_signal_raw<int32_t>(buf, 0, 32, true);
    }

    static const uint8_t cmd_id = 0x019;
    static const uint8_t msg_length = 8;

    int Position = 0; 
};

/**
 * @struct Set_Pos_Gain_msg_t
 * @brief Set Position gain for controllers
 *
 * Command ID: 0x0A
 * Payload: 8 bytes
 * 
 */
struct Set_Pos_Gain_msg_t final
{
    constexpr Set_Pos_Gain_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Set_Pos_Gain_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, Pos_Gain, 0, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Pos_Gain = can_get_signal_raw<float>(buf, 0, 32, true);
    }

    static const uint8_t cmd_id = 0x01A;
    static const uint8_t msg_length = 8;

    float Pos_Gain = 0.0f; // [(rev/s) / rev]
};

struct Set_Vel_Gains_msg_t final
{
    constexpr Set_Vel_Gains_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Set_Vel_Gains_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, Vel_Gain, 0, 32, true);
        can_set_signal_raw<float>(buf, Vel_Integrator_Gain, 32, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Vel_Gain = can_get_signal_raw<float>(buf, 0, 32, true);
        Vel_Integrator_Gain = can_get_signal_raw<float>(buf, 32, 32, true);
    }

    static const uint8_t cmd_id = 0x01B;
    static const uint8_t msg_length = 8;

    float Vel_Gain = 0.0f;            // [Nm / (rev/s)]
    float Vel_Integrator_Gain = 0.0f; // [Nm / rev]
};

struct Get_ADC_Voltage_msg_t final
{
    constexpr Get_ADC_Voltage_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Get_ADC_Voltage_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<float>(buf, ADC_Voltage, 0, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        ADC_Voltage = can_get_signal_raw<float>(buf, 0, 32, true);
    }

    static const uint8_t cmd_id = 0x01C;
    static const uint8_t msg_length = 8;

    float ADC_Voltage = 0.0f;
};

struct Get_Controller_Error_msg_t final
{
    constexpr Get_Controller_Error_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    Get_Controller_Error_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
        can_set_signal_raw<uint32_t>(buf, Controller_Error, 0, 32, true);
    }

    void decode_buf(const uint8_t *buf)
    {
        Controller_Error = can_get_signal_raw<uint32_t>(buf, 0, 32, true);
    }

    static const uint8_t cmd_id = 0x01D;
    static const uint8_t msg_length = 8;

    int Controller_Error = 0;
};

struct CANOpen_Heartbeat_Message_msg_t final
{
    constexpr CANOpen_Heartbeat_Message_msg_t() = default;

#ifdef ODRIVE_CAN_MSG_TYPE
    CANOpen_Heartbeat_Message_msg_t(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_msg(msg);
    }

    void encode_msg(TBoard::TCanIntf::TMsg &msg)
    {
        encode_buf(can_msg_get_payload(msg).data());
    }

    void decode_msg(const TBoard::TCanIntf::TMsg &msg)
    {
        decode_buf(can_msg_get_payload(msg).data());
    }
#endif

    void encode_buf(uint8_t *buf) const
    {
    }

    void decode_buf(const uint8_t *buf)
    {
    }

    static const uint8_t cmd_id = 0x700;
    static const uint8_t msg_length = 0;
};
